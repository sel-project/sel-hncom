/*
 * Copyright (c) 2017-2018 SEL
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 * 
 */
/**
 * Copyright: Copyright (c) 2017-2018 sel-project
 * License: MIT
 * Authors: Kripth
 * Source: $(HTTP github.com/sel-project/sel-hncom/sel/hncom/status.d, sel/hncom/status.d)
 */
module sel.hncom.status;

import std.json : JSONValue;
import std.socket : Address;
import std.typecons : Tuple;
import std.uuid : UUID;

import sel.hncom.about;
import sel.hncom.io : IO;

/**
 * Used to calculate latency by both the hub and the node.
 * When this packet is received it should be immeditaly sent back to the sender
 * without any change.
 */
@clientbound @serverbound struct Latency {

	enum ubyte ID = 7;

	/**
	 * Id of the ping/pong. Should be unique for the session.
	 */
	uint id;

	mixin IO!(id);

}

/**
 * Sends a logged message to the hub.
 */
@serverbound struct Log {

	enum ubyte ID = 8;
	
	alias Message = Tuple!(bool, "translation", string, "message", string[], "params");

	enum int NO_COMMAND = -1;
	
	enum int NO_WORLD = -1;

	/**
	 * Logged message or translation. It may contain Minecraft formatting codes.
	 */
	Message[] message;
	
	/**
	 * Unix time (in milliseconds) that indicates the exact creation time of the
	 * log (for ordering purposes).
	 */
	ulong timestamp;

	/**
	 * Identifier of the command that has generated the log or -1 if the
	 * log wasn't generated by a command.
	 */
	int commandId = NO_COMMAND;
	
	/**
	 * Id of the world that has generated the log, if the log comes from a world, -1 otherwise.
	 */
	int worldId = NO_WORLD;

	mixin IO!(message, timestamp, commandId, worldId);

}

/**
 * Executes a command on the node.
 */
@clientbound struct RemoteCommand {
	
	enum ubyte ID = 9;
	
	enum : ubyte {
		
		HUB = 0,
		WEB_ADMIN = 1,
		RCON = 2,
		
	}
	
	/**
	 * Origin of the command. It could be the hub itself or an external source.
	 */
	ubyte origin;
	
	/**
	 * Address of the sender if the command has been sent from an external source.
	 * It's `null` when the hub is the sender.
	 */
	Address sender;
	
	/**
	 * Commands and arguments that should be executed on the node.
	 * For example `say hello world` or `kill @a`.
	 */
	string command;
	
	/**
	 * Identifier of the command. It's sent back in Log's commandId field
	 * when the command generates output.
	 */
	uint commandId;
	
	mixin IO!(origin, sender, command, commandId);
	
}

/**
 * Notifies the node that another node (that is not the receiver) has connected to the hub.
 */
@clientbound struct AddNode {

	enum ubyte ID = 10;

	/**
	 * Identifier given by the hub to uniquey identify the node.
	 */
	uint hubId;

	/**
	 * Node's name used for displaying and identification purposes.
	 */
	string name;

	/**
	 * Whether the node is a main node.
	 */
	bool main;

	/**
	 * Indicates the games and protocols accepted by the node.
	 */
	uint[][ubyte] acceptedGames;

	mixin IO!(hubId, name, main, acceptedGames);

}

/**
 * Notifies the node that another node, previously added with AddNode,
 * has disconnected from the hub.
 */
@clientbound struct RemoveNode {

	enum ubyte ID = 11;

	/**
	 * Node's id given by the hub.
	 */
	uint hubId;

	mixin IO!(hubId);

}

/**
 * Receives a binary message sent by another node using SendMessage.
 */
@clientbound struct ReceiveMessage {

	enum ubyte ID = 12;

	/**
	 * Id of the node that has sent the message.
	 */
	uint sender;

	/**
	 * Indicates whether the message was broadcasted to every connected node.
	 */
	bool broadcasted;

	/**
	 * Bytes received. It could be serialised data or a plugin-defined packet.
	 */
	ubyte[] payload;

	mixin IO!(sender, payload);

}

/**
 * Sends a binary message to some selected nodes or broadcast it.
 */
@serverbound struct SendMessage {
	
	enum ubyte ID = 13;

	/**
	 * Addressees of the message. If the array is empty the message is
	 * broadcasted to every connected node but the sender.
	 */
	uint[] addressees;

	/**
	 * Bytes to be sent/broadcasted. It may be serialised data or a plugin-defined packet.
	 */
	ubyte[] payload;

	mixin IO!(addressees, payload);
	
}

/**
 * Updates the server's display name.
 */
@clientbound struct UpdateDisplayName {

	enum ubyte ID = 14;

	string displayName;

	mixin IO!(displayName);

}

/**
 * Updates the MOTD of one of the supported games.
 */
@clientbound struct UpdateMOTD {

	enum ubyte ID = 15;

	ubyte type;

	string motd;

	mixin IO!(type, motd);

}

/**
 * Updates the number of players on the server.
 */
@clientbound struct UpdatePlayers {

	enum ubyte ID = 16;

	enum int UNLIMITED = -1;

	/**
	 * Players currently online in the whole server (connected to a node).
	 */
	uint online;

	/**
	 * Maximum number of players that can connect to server, which is the sum of
	 * the max players of every connected node.
	 */
	int max;

	mixin IO!(online, max);

}

/**
 * Updates the number of players that can be accepted by the node.
 * If the given number is smaller than the players currently connected
 * to the node no player should be kicked.
 */
@serverbound struct UpdateMaxPlayers {

	enum ubyte ID = 17;

	enum uint UNLIMITED = 0;

	/**
	 * Maximum number of players accepted by node.
	 */
	uint max;

	mixin IO!(max);

}

/**
 * Updates the accepted protocols for one of the supported games.
 */
@clientbound struct UpdateSupportedProtocols {

	enum ubyte ID = 18;
	
	ubyte game;
	
	uint[] protocols;
	
	mixin IO!(game, protocols);
	
}

/**
 * Updates the usage of the system's resources of the node.
 */
@serverbound struct UpdateUsage {

	enum ubyte ID = 19;

	/**
	 * Kibibytes of RAM used by the node.
	 */
	uint ram;

	/**
	 * Percentage of CPU used by the node. It may be higher than 100
	 * if the node has more than 1 CPU
	 */
	float cpu;

	mixin IO!(ram, cpu);

}

/**
 * Updates the language files. The content of this packet is usually
 * readed from plugins' language files.
 */
@serverbound struct UpdateLanguageFiles {

	enum ubyte ID = 20;

	string language;

	string[string] messages;

	mixin IO!(language, messages);

}

/**
 * Adds a plugin that has been loaded at runtime.
 */
@serverbound struct AddPlugin {

	enum ubyte ID = 21;

	/**
	 * Plugin's id given by the node. It must be unique.
	 */
	uint id;

	string name;

	string version_;

	mixin IO!(id, name, version_);

}

/**
 * Removes a plugin that has been unloaded at runtime.
 */
@serverbound struct RemovePlugin {

	enum ubyte ID = 22;

	/**
	 * Plugin's id given in the NodeInfo packet or in the AddPlugin packet.
	 */
	uint id;

	mixin IO!(id);

}

/**
 * Notifies the hub that a new world has been created on the node.
 */
@serverbound struct AddWorld {
	
	enum ubyte ID = 23;

	/**
	 * Id of the world. Must be unique on the node.
	 */
	uint worldId;

	/**
	 * Name of the world, it doesn't need to be unique.
	 */
	string name;

	/**
	 * World's dimension in the MCPE format (0: overworld, 1: nether, 2: end).
	 */
	ubyte dimension;

	/**
	 * Indicates whether the world is the node's default (the one where new players
	 * are spawned into if not handled by plugins).
	 * If the node does not support default worlds or it simply doesn't have one
	 * this field should be left to its default value (false).
	 * If the hub receives more than one default world it should consider the last
	 * received one as the default world.
	 */
	bool default_;

	/**
	 * Id of the world's parent or -1 if the world has no parent. This is usually used
	 * for nether/end which are children of an overworld world.
	 */
	int parent = -1;
	
	mixin IO!(worldId, name, dimension, parent);
	
}

/**
 * Notifies the hub that a world has been removed from the node.
 */
@serverbound struct RemoveWorld {
	
	enum ubyte ID = 24;

	/**
	 * Id of the world that has been removed, previosly added using the
	 * AddWorld packet.
	 */
	uint worldId;
	
	mixin IO!(worldId);
	
}

/**
 * Gives the node the credentials that will be used by a remote panel
 * client to connect to a world.
 */
@clientbound struct WebAdminCredentials {

	enum ubyte ID = 25;

	/**
	 * Id of the request, generated by the hub. To the request are associated the
	 * login credentials and the world to track.
	 */
	uint requestId;

	/**
	 * Address used by the client to connect. May be a represantion of
	 * an ipv4 (`134.56.1.55`), ipv6 (`44:5:12::9`) or unix address (`~/tmp/rc`).
	 */
	string address;

	/**
	 * Hash generated by the hub that will be used by the remote panel to
	 * perform authentication.
	 */
	ubyte[32] hash;

	/**
	 * World that the remote panel client will connect to.
	 */
	uint worldId;

	mixin IO!(requestId, address, hash, worldId);

}
